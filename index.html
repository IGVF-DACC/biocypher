<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; BioCypher  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> BioCypher
          </a>
              <div class="version">
                0.1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Introduction</a></li>
<li><a class="reference internal" href="#quickstart">Quickstart</a><ul>
<li><a class="reference internal" href="#the-host-module-adapter">The host module adapter</a></li>
<li><a class="reference internal" href="#the-schema-configuration-yaml-file">The schema configuration YAML file</a></li>
<li><a class="reference internal" href="#the-biolink-model-extension">The Biolink model extension</a><ul>
<li><a class="reference internal" href="#soft-extensions">Soft extensions</a></li>
<li><a class="reference internal" href="#hard-wired-extensions">Hard-wired extensions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-host-biocypher-adapter">The Host-BioCypher Adapter</a><ul>
<li><a class="reference internal" href="#loading-the-data">Loading the Data</a></li>
<li><a class="reference internal" href="#passing-the-data">Passing the Data</a></li>
<li><a class="reference internal" href="#communication-via-the-neo4j-python-driver">Communication via the Neo4j Python Driver</a></li>
<li><a class="reference internal" href="#interacting-with-a-running-neo4j-instance">Interacting with a running Neo4j instance</a></li>
<li><a class="reference internal" href="#exporting-for-the-neo4j-admin-import-feature">Exporting for the <cite>neo4j-admin import</cite> feature</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usage-notes">Usage Notes</a></li>
<li><a class="reference internal" href="#submodule-documentation">Submodule documentation</a><ul>
<li><a class="reference internal" href="#driver-py-the-biocypher-neo4j-driver"><cite>driver.py</cite>: the BioCypher Neo4j Driver</a></li>
<li><a class="reference internal" href="#check-py-biocypher-format-data-representation-and-consistency-checks"><cite>check.py</cite>: BioCypher Format Data Representation and Consistency Checks</a></li>
<li><a class="reference internal" href="#create-py-base-classes-for-node-and-edge-representations-in-biocypher"><cite>create.py</cite>: Base Classes for Node and Edge Representations in BioCypher</a></li>
<li><a class="reference internal" href="#translate-py-translation-functionality-for-implemented-types-of-representation"><cite>translate.py</cite>: Translation Functionality for Implemented Types of Representation</a></li>
<li><a class="reference internal" href="#write-py-write-the-graph-to-csv-files-for-quick-admin-import"><cite>write.py</cite>: Write the Graph to CSV Files for quick ‘admin import’</a></li>
<li><a class="reference internal" href="#logger-py-logging"><cite>logger.py</cite>: Logging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-tables-and-search">Indices, Tables, and Search</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">BioCypher</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <img alt="_images/biocypher-open-graph.png" src="_images/biocypher-open-graph.png" />
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h1>
<p>BioCypher (<a class="reference external" href="https://github.com/saezlab/BioCypher">GitHub</a>) is designed
to serve as guideline and translation mechanism for both the creation of
biomedical property graph databases from primary data as well as for the
seamless integration, optimisation, and querying of these databases. The
purpose is to combine the computational power of graph databases with
the search for answers of our most pressing biological questions and
facilitate interfacing with cutting edge developments in the areas of
causal reasoning, representation learning, and natural language
processing, all of which depend on having a consistent descriptive
vocabulary. To achieve meaningful automatic representations in the
biomedical language space, we include the <a class="reference external" href="https://biolink.github.io/biolink-model/">Biolink model</a> as underlying hierarchical
ontology, supplying identification, filtering, and mapping capabilities.
We are also keeping an open mind about adding alternative ontological
systems using an opt-in philosophy. Side objectives are the creation of
human-readable graph syntax and facilitating ultra-rapid graph creation
through the Neo4j <a class="reference internal" href="#admin-import"><span class="std std-ref">admin-import</span></a> feature.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>BioCypher is currently in prototype state; we are working on a
full-featured implementation for the migration of OmniPath at the
moment. Functionality regarding the translation between different
database formats and identifiers therefore is rudimentary or
non-existent as of now.</p>
</div>
</section>
<section id="quickstart">
<h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this heading"></a></h1>
<p>The main interface for interacting with the BioCypher module to create
your own property graph consists of two components:</p>
<ol class="arabic simple">
<li><p>the <a class="reference internal" href="#host-module-adapter"><span class="std std-ref">host module adapter</span></a>, a python
program, and</p></li>
<li><p>the <a class="reference internal" href="#schema-config"><span class="std std-ref">schema configuration file</span></a>, a YAML file.</p></li>
</ol>
<p>The adapter serves as a data interface between the source and BioCypher,
piping the “raw” data into BioCypher for the creation of the property
graph, while the schema configuration tells BioCypher how the graph
should be structured, detailing the names of constituents and how they
should be connected.</p>
<section id="the-host-module-adapter">
<span id="host-module-adapter"></span><h2>The host module adapter<a class="headerlink" href="#the-host-module-adapter" title="Permalink to this heading"></a></h2>
<p>Currently, BioCypher expects input from the user module via an adapter
module. Throughout the tutorial, we will exemplarise the use of
BioCypher using <a class="reference external" href="https://omnipathdb.org">OmniPath</a> (more specifically,
its infrastructural backend, <a class="reference external" href="https://github.com/saezlab/pypath">PyPath</a>). The adapter has the job of
piping the data as it is represented in the original database into the
BioCypher input, for instance as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code> object of
single database entries, whether they be nodes or relationships in the
graph to be created. For more details, please refer to the example
<a class="reference external" href="https://github.com/saezlab/pypath/blob/master/pypath/biocypher/adapter.py">PyPath adapter</a>
and the section on <a class="reference internal" href="#adapter"><span class="std std-ref">adapter functions</span></a>.</p>
</section>
<section id="the-schema-configuration-yaml-file">
<span id="schema-config"></span><h2>The schema configuration YAML file<a class="headerlink" href="#the-schema-configuration-yaml-file" title="Permalink to this heading"></a></h2>
<p>The second important component of translation into a
BioCypher-compatible property graph is the specification of graph
constituents and their mode of representation in the graph. For
instance, we want to add a representation for proteins to the OmniPath
graph, and the proteins should be represented as nodes. To make this
known to the BioCypher module, we use the <a class="reference external" href="https://github.com/saezlab/BioCypher/blob/main/config/schema_config.yaml">schema-config.yaml</a>,
which details <em>only</em> the immediate constituents of the desired graph.
The naming of these constituents must be equal to the ontological
category of the entity in the Biolink schema. The ontological category
(or class) of proteins in Biolink is simply <a class="reference external" href="https://biolink.github.io/biolink-model/docs/Protein.html">Protein</a>. However,
for more complex concepts, such as - for instance - pairwise molecular
interactions, the naming must also be consistent; in this case,
<a class="reference external" href="https://biolink.github.io/biolink-model/docs/PairwiseMolecularInteraction.html">PairwiseMolecularInteraction</a>.
Similarly, if translation functionality between identifiers is desired,
the identifier used for the class of graph entity must be consistent
with the one used in the Biolink specification. For proteins, this can
be <code class="docutils literal notranslate"><span class="pre">UniProtKB</span></code> (but not, for instance, <code class="docutils literal notranslate"><span class="pre">UniProt</span></code> or <code class="docutils literal notranslate"><span class="pre">uniprot</span></code>).
For ease of access, we provide a standard yaml file with the most common
graph constituents and identifiers, with the following basic structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Protein</span><span class="p">:</span>

   <span class="n">represented_as</span><span class="p">:</span> <span class="n">node</span>

   <span class="n">preferred_id</span><span class="p">:</span> <span class="n">UniProtKB</span>

   <span class="n">label_in_input</span><span class="p">:</span> <span class="n">protein</span>
</pre></div>
</div>
<p>In the protein case, we are specifying its representation as a node,
that we wish to use the UniProt identifier as the main identifier for
proteins (the Biolink designation for UniProt identifiers is
<code class="docutils literal notranslate"><span class="pre">UniProtKB</span></code>), and that proteins in the input coming from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code>
carry the label <code class="docutils literal notranslate"><span class="pre">protein</span></code> (in lower-case).</p>
<p>The other slots of a graph constituent entry contain information
BioCypher needs to receive the input data correctly and construct the
graph accordingly. For “Named Thing” entities such as the protein, this
includes the mode of representation (YAML entry <code class="docutils literal notranslate"><span class="pre">represented_as</span></code>),
which can be <code class="docutils literal notranslate"><span class="pre">node</span></code> or <code class="docutils literal notranslate"><span class="pre">edge</span></code>. Proteins can only feasibly
represented as nodes, but for other entities, such as interactions or
aggregates, representation can be both as node or as edge. In Biolink,
these belong to the super-class <a class="reference external" href="https://biolink.github.io/biolink-model/docs/associations.html">Associations</a>. For
associations, BioCypher additionally requires the specification of the
source and target of the association; for instance, a post-translational
interaction occurs between proteins, so the source and target attribute
in the <code class="docutils literal notranslate"><span class="pre">schema-config.yaml</span></code> will both be <code class="docutils literal notranslate"><span class="pre">Protein</span></code>. Again, these
should adhere to the naming scheme of Biolink.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PostTranslationalInteraction</span><span class="p">:</span>

   <span class="n">represented_as</span><span class="p">:</span> <span class="n">node</span>

   <span class="n">preferred_id</span><span class="p">:</span> <span class="n">concat_ids</span>

   <span class="n">source</span><span class="p">:</span> <span class="n">Protein</span>

   <span class="n">target</span><span class="p">:</span> <span class="n">Protein</span>

   <span class="n">label_in_input</span><span class="p">:</span> <span class="n">post_translational</span>

   <span class="n">label_as_edge</span><span class="p">:</span> <span class="n">INTERACTS_POST_TRANSLATIONAL</span>
</pre></div>
</div>
<p>For the post-translational interaction, which is an association, we are
specifying representation as a node (prompting BioCypher to create not
only the node but also two edges connecting to the proteins
participating in any particular post-translational interaction). In
other words, we are reifying the post-translational interaction in order
to have a node to which other nodes can be linked; for instance, we
might want to add a publication to a particular interaction to serve as
source of evidence, which is only possible for nodes in a property
graph, not for edges.</p>
<p>Since there are no systematic identifiers for post-translational
interactions, we concatenate the protein ids and relevant properties of
the interaction to a new unique id (arbitrarily named <code class="docutils literal notranslate"><span class="pre">concat_ids</span></code>).
Note that BioCypher accepts non-Biolink IDs since not all possible
entries possess a systematic identifier system, whereas the entity class
(<code class="docutils literal notranslate"><span class="pre">Protein</span></code>, <code class="docutils literal notranslate"><span class="pre">PostTranslationalInteraction</span></code>) has to be included in
the Biolink schema and spelled identically. For this reason, we
<a class="reference internal" href="#biolink"><span class="std std-ref">extend the Biolink schema</span></a> in cases where there exists
no entry for our entity of choice.</p>
<p>Further, we are specifying the source and target classes of our
association (both <code class="docutils literal notranslate"><span class="pre">Protein</span></code>), the label we provide in the input from
<code class="docutils literal notranslate"><span class="pre">PyPath</span></code> (<code class="docutils literal notranslate"><span class="pre">post_translational</span></code>), and - optionally - the label we
would want the edge in the graph to carry would the association be
represented as an edge. This has no bearing on the current example,
where we choose representation as a node, but is important for edge
representation, as by consensus, property graph edges are represented in
all upper case form and as verbs, to distinguish from nodes that are
represented in PascalCase and as nouns.</p>
</section>
<section id="the-biolink-model-extension">
<span id="biolink"></span><h2>The Biolink model extension<a class="headerlink" href="#the-biolink-model-extension" title="Permalink to this heading"></a></h2>
<section id="soft-extensions">
<h3>Soft extensions<a class="headerlink" href="#soft-extensions" title="Permalink to this heading"></a></h3>
<p>In some cases that are not too complex, the Biolink model can be
extended using only implicit subclasses given in the BioCypher
schema_config.yaml file. For instance, Pathway annotations are supplied
by multiple sources, e.g., <a class="reference external" href="https://www.genome.jp/kegg/pathway.html">KEGG</a> and Reactome, which do not
allow direct mapping due to their distinct make-up. In this case, we can
use the schema_config.yaml to implicitly extend the Biolink model by
specifying more than one preferred_id and label_in_input (in a paired
manner):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Pathway</span><span class="p">:</span>

   <span class="n">represented_as</span><span class="p">:</span> <span class="n">node</span>

   <span class="n">preferred_id</span><span class="p">:</span> <span class="p">[</span><span class="n">REACT</span><span class="p">,</span> <span class="n">KEGG</span><span class="p">]</span>

   <span class="n">label_in_input</span><span class="p">:</span> <span class="p">[</span><span class="n">reactome</span><span class="p">,</span> <span class="n">kegg_pathway</span><span class="p">]</span>
</pre></div>
</div>
<p>This pattern will be parsed by BioCypher to yield two implicit children
of the Biolink entity “Pathway” by prepending the preferred ID to the
label (“REACT.Pathway” and “KEGG.Pathway”). The input labels again are
arbitrary and can be adjusted to fit the way these pathways are
represented in the raw data.</p>
<p>This will allow both datasets to be represented as pathways in the final
graph with granular access to each one and without information loss, but
will also enable aggregate query of all pathways by calling the parent
entity, “Pathway”.</p>
</section>
<section id="hard-wired-extensions">
<h3>Hard-wired extensions<a class="headerlink" href="#hard-wired-extensions" title="Permalink to this heading"></a></h3>
<p>The post-translational interaction that we would like to model in
OmniPath has no literal counterpart in the Biolink model, due to
Biolink’s design philosophy. The most granular level of interactions as
Biolink class is the <a class="reference external" href="https://biolink.github.io/biolink-model/docs/PairwiseMolecularInteraction.html">PairwiseMolecularInteraction</a>;
all more granular relationships should be encoded in the properties of
the class, which has severe performance implications for property graph
representation, for instance in filtering for specific relationship
types. Briefly, it is the difference between being able to selectively
return only relationships of a certain class (eg, post-translational),
and having to return all relationships to filter for the ones possessing
the correct property in a second step.</p>
<p>Therefore, we extend the Biolink model in places where it is necessary
for the BioCypher translation and integration to work. The extended
model is the central Biolink YAML file with additions following the same
<a class="reference external" href="https://linkml.io">LinkML</a> syntax as is used in the original model.
Depending on the extent of the modification, not only new classes are
introduced, but also new mixin categories (eg, “microRNA or siRNA” to
account for different types of small noncoding RNA). We provide <a class="reference external" href="https://github.com/saezlab/BioCypher/blob/main/config/biocypher-biolink-model.yaml">our
extended version of the Biolink model</a>
with the BioCypher repository.</p>
<p>Changes or additions desired by the user can be introduced locally in
this file without having to modify remote contents. Users also have the
option to create their own modified version of the Biolink YAML file
under a different file name and specify that path in the
<code class="docutils literal notranslate"><span class="pre">custom_yaml_file</span></code> argument of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.translate.BiolinkAdapter</span></code> class, which handles all
communication between BioCypher and Biolink.</p>
</section>
</section>
</section>
<section id="the-host-biocypher-adapter">
<span id="adapter"></span><h1>The Host-BioCypher Adapter<a class="headerlink" href="#the-host-biocypher-adapter" title="Permalink to this heading"></a></h1>
<p>The “BioCypher adapter” is a python program (in the case of <code class="docutils literal notranslate"><span class="pre">PyPath</span></code>,
a submodule) responsible for piping the data that is to be represented
in the graph into BioCypher in a somewhat arbitrary format. It is an
expansion tailor-made for the source database as an interface to
BioCypher; in developing BioCypher, we strive to make its structure as
simple as possible to facilitate adaptation. Thus, the adapter usually
consists of only few central functions needed for the transfer of data
between the arbitrarily ordered source format and the highly
“automatically compatible” target format of BioCypher. In our example,
the adapter performs three main functions (with functions 2 and 3 being
mutually optional):</p>
<ol class="arabic simple">
<li><p>Load the <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> data python object to be transferred to BioCypher</p></li>
<li><p>Pass the data to BioCypher as a stream or list to be written to the
Neo4j database via the python driver (“online”)</p></li>
<li><p>Pass the data to BioCypher as a stream or list to be written to the
Neo4j database via admin import (batch import from CSV)</p></li>
</ol>
<p>While function #2 can be performed at any time with a new or
pre-existing BioCypher graph, function #3 can only be used to create a
fresh database from scratch with all the input data. However, since
<code class="docutils literal notranslate"><span class="pre">neo4j-admin</span> <span class="pre">import</span></code> is very fast, it can be used to combine subsets
of two databases on the fly, creating a new, combined database in the
process.</p>
<section id="loading-the-data">
<h2>Loading the Data<a class="headerlink" href="#loading-the-data" title="Permalink to this heading"></a></h2>
<p>Depending on the data source, it is up to the user to find and define a
suitable representation to be piped into BioCypher. The way we handle it
in <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> is only one of many: we load the entire <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> object
into memory, to be passed to BioCypher using a generator that evaluates
each <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> object and transforms it to the tuple representation
described below. This is made possible by the already standardised form
in which the data is represented within <code class="docutils literal notranslate"><span class="pre">PyPath</span></code>. For more
heterogeneous data representations, additional transformations may be
necessary before piping into BioCypher.</p>
</section>
<section id="passing-the-data">
<h2>Passing the Data<a class="headerlink" href="#passing-the-data" title="Permalink to this heading"></a></h2>
<p>In the <a class="reference external" href="https://github.com/saezlab/pypath/blob/fc4c959c168ce80427189f8dd237308707594ad0/src/pypath/biocypher/adapter.py#L189">pypath example</a>,
we are using <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code>-type objects to pass an unordered
collection of <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> contents into BioCypher. For nodes, we are
specifying for each object an ID and label (corresponding to its unique
preferred identifier and its ontological class), as well as a dictionary
of arbitrary properties, each entry as a 3-tuple. For relationships, the
same applies, except that we are passing two IDs, for source and target
entities, which results in a 4-tuple.</p>
<p>Currently, there are two modes of interaction with the graph database
implemented in BioCypher. The first takes place via the Neo4j python
driver, which is either loaded by BioCypher or passed from the host
module. The second generates CSV files containing node and edge data in
a standardised and safety-checked format to be used with the <code class="docutils literal notranslate"><span class="pre">admin</span>
<span class="pre">import</span></code> functionality of Neo4j. Safety checks are important here
because Neo4j does not guarantee consistency of the resulting graph when
using this feature; on the upside, this mode of communication is much
faster. However, it can only be used when creating a new graph, not for
changing an already existing one.</p>
</section>
<section id="communication-via-the-neo4j-python-driver">
<h2>Communication via the Neo4j Python Driver<a class="headerlink" href="#communication-via-the-neo4j-python-driver" title="Permalink to this heading"></a></h2>
<p>The BioCypher <a class="reference internal" href="#driver"><span class="std std-ref">Driver</span></a> is the main submodule of BioCypher.
It establishes a connection with a running graph database via the
<code class="xref py py-class docutils literal notranslate"><span class="pre">neo4j.GraphDatabase.driver</span></code>, integrates the funtions of the
other submodules, and serves as outside interface of BioCypher. The
<code class="docutils literal notranslate"><span class="pre">Driver</span></code> is the main class for interacting with BioCypher in the host
module’s adapter class. It handles authentification and basic database
management as well as the creation and manipulation of graph entries.</p>
<p>In our example, it is instantiated in the initialisation of the adapter,
and then called on for <a class="reference internal" href="#running"><span class="std std-ref">interacting with a running graph</span></a>
and for exporting a complete database in CSV format for the <a class="reference internal" href="#admin-import"><span class="std std-ref">Neo4j
admin-import feature</span></a>. Upon instantiation, it
automatically assesses the graph database it is connected to (specified
using the <code class="docutils literal notranslate"><span class="pre">db_name</span></code> attribute) regarding whether or not it already
contains a BioCypher graph, and, if so, what the structure of this graph
is.</p>
<p>If there exists no BioCypher graph in the currently active database, or
if the user explicitly specifies so using the <code class="docutils literal notranslate"><span class="pre">wipe</span></code> attribute of the
driver, a new BioCypher database is created using the schema
configuration specified in the <a class="reference internal" href="#schema-config"><span class="std std-ref">schema-config.yaml</span></a>.</p>
</section>
<section id="interacting-with-a-running-neo4j-instance">
<span id="running"></span><h2>Interacting with a running Neo4j instance<a class="headerlink" href="#interacting-with-a-running-neo4j-instance" title="Permalink to this heading"></a></h2>
<p>Once instantiated, the BioCypher driver can be used to modify the
current graph by adding or deleting nodes, edges, properties,
constraints, et cetera. Most commonly, the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.driver.Driver.add_nodes()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.driver.Driver.add_edges()</span></code> are used to introduce new
entries into the graph database.</p>
</section>
<section id="exporting-for-the-neo4j-admin-import-feature">
<span id="admin-import"></span><h2>Exporting for the <cite>neo4j-admin import</cite> feature<a class="headerlink" href="#exporting-for-the-neo4j-admin-import-feature" title="Permalink to this heading"></a></h2>
<p>Particularly if the data are very extensive (or performance is of the
utmost priority), BioCypher can be used to facilitate a speedy and safe
import of the data using the <code class="docutils literal notranslate"><span class="pre">neo4j-admin</span> <span class="pre">import</span></code> console command.
<a class="reference external" href="https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/">Admin Import</a>
is a particularly fast method of writing data to a newly created graph
database (the database needs to be completely empty) that gains most of
its performance advantage from turning off safety features regarding
input data consistency. Therefore, a sound and consistent representation
of the nodes and edges in the graph is of high importance in this
process, which is why the BioCypher export functionality has been
specifically designed to perform type and content checking for all data
to be written to the graph.</p>
<p>Data input from the source database is exactly as in the case of
<a class="reference external" href="running">interacting with a running database</a>, with the data
representation being converted to a series of CSV files in a designated
output folder (standard being <code class="docutils literal notranslate"><span class="pre">out/</span></code> and the current datetime).
BioCypher creates separate header and data files for all node and edge
types to be represented in the graph via the driver methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.driver.Driver.write_nodes()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.driver.Driver.write_edges()</span></code>. Additionally, it creates
a file called <code class="docutils literal notranslate"><span class="pre">neo4j-admin-import-call.txt</span></code> containing the console
command for creating a new database, which only has to be executed from
the directory of the currently running Neo4j database.</p>
<p>The name of the database to be created is given by the <code class="docutils literal notranslate"><span class="pre">db_name</span></code>
attribute of the driver methods, ie, <code class="docutils literal notranslate"><span class="pre">write_nodes()</span></code> and
<code class="docutils literal notranslate"><span class="pre">write_edges()</span></code>, which should receive the same name as in the
<code class="docutils literal notranslate"><span class="pre">PyPath</span></code> adapter example, and can be arbitrary. In case the
<code class="docutils literal notranslate"><span class="pre">db_name</span></code> is not the default Neo4j database name, <code class="docutils literal notranslate"><span class="pre">neo4j</span></code>, the
database needs to be created in Neo4j before or after using the
<code class="docutils literal notranslate"><span class="pre">neo4j-admin</span> <span class="pre">import</span></code> statement. This can be done by executing, in the
running database (<code class="docutils literal notranslate"><span class="pre">&lt;db_name&gt;</span></code> being the name assigned in the method):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">:use</span> <span class="pre">system</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">create</span> <span class="pre">database</span> <span class="pre">&lt;db_name&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:use</span> <span class="pre">&lt;db_name&gt;</span></code></p></li>
</ol>
</section>
</section>
<section id="usage-notes">
<h1>Usage Notes<a class="headerlink" href="#usage-notes" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p>A graph database can be built from any arbitrary collection of
biomedical data. We here examplarise the building of a biological
prior knowledge graph from the OmniPath database (Türei et al. 2021),
but BioCypher includes the extensive translation functionality from
<code class="docutils literal notranslate"><span class="pre">PyPath</span></code> to accommodate custom requirements for graph database
contents.</p></li>
<li><p>A BioCypher graph has to be instantiated as such from the beginning,
an existing property graph cannot currently be “updated” to conform
to the BioCypher format.</p></li>
<li><p>As a first step, an empty Neo4j database has to be created and
started; the Python database driver can then be established either
through BioCypher directly or on the user’s end and passed to
BioCypher (if there is greater need for data security in
authentication).</p></li>
<li><p>After the database driver has been passed to BioCypher, a new
database can be established given the selected data structure, to be
determined in the primary configuration file. In this step, all
constraints and indices are set to conform to the selected database
structure. These can also be modified afterwards.</p>
<ul>
<li><p>Note: if the database to be created is very extensive, BioCypher
offers a “secure export” method to create CSV files that can be
used to instantiate a new graph database very quickly using the
<a class="reference external" href="https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/">Admin Import</a>
feature of Neo4j.</p></li>
</ul>
</li>
<li><p>The database structure and version are recorded in a meta-graph that
serves as a versioning system and simultaneously as a means of
transmitting information about the graph structure for the case of
re-loading an existing database for updating it with new information.</p></li>
</ul>
</section>
<section id="submodule-documentation">
<h1>Submodule documentation<a class="headerlink" href="#submodule-documentation" title="Permalink to this heading"></a></h1>
<section id="driver-py-the-biocypher-neo4j-driver">
<span id="driver"></span><h2><cite>driver.py</cite>: the BioCypher Neo4j Driver<a class="headerlink" href="#driver-py-the-biocypher-neo4j-driver" title="Permalink to this heading"></a></h2>
</section>
<section id="check-py-biocypher-format-data-representation-and-consistency-checks">
<h2><cite>check.py</cite>: BioCypher Format Data Representation and Consistency Checks<a class="headerlink" href="#check-py-biocypher-format-data-representation-and-consistency-checks" title="Permalink to this heading"></a></h2>
</section>
<section id="create-py-base-classes-for-node-and-edge-representations-in-biocypher">
<h2><cite>create.py</cite>: Base Classes for Node and Edge Representations in BioCypher<a class="headerlink" href="#create-py-base-classes-for-node-and-edge-representations-in-biocypher" title="Permalink to this heading"></a></h2>
</section>
<section id="translate-py-translation-functionality-for-implemented-types-of-representation">
<h2><cite>translate.py</cite>: Translation Functionality for Implemented Types of Representation<a class="headerlink" href="#translate-py-translation-functionality-for-implemented-types-of-representation" title="Permalink to this heading"></a></h2>
</section>
<section id="write-py-write-the-graph-to-csv-files-for-quick-admin-import">
<h2><cite>write.py</cite>: Write the Graph to CSV Files for quick ‘admin import’<a class="headerlink" href="#write-py-write-the-graph-to-csv-files-for-quick-admin-import" title="Permalink to this heading"></a></h2>
</section>
<section id="logger-py-logging">
<h2><cite>logger.py</cite>: Logging<a class="headerlink" href="#logger-py-logging" title="Permalink to this heading"></a></h2>
</section>
</section>
<section id="indices-tables-and-search">
<h1>Indices, Tables, and Search<a class="headerlink" href="#indices-tables-and-search" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<div class="toctree-wrapper compound">
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, BioCypher developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>