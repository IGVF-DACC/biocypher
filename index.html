<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; BioCypher  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> BioCypher
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Introduction</a></li>
<li><a class="reference internal" href="#quickstart">Quickstart</a><ul>
<li><a class="reference internal" href="#the-host-module-adapter">The host module adapter</a></li>
<li><a class="reference internal" href="#the-schema-configuration-yaml-file">The schema configuration YAML file</a><ul>
<li><a class="reference internal" href="#the-biolink-model-extension">The Biolink model extension</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-adapter">The Adapter</a><ul>
<li><a class="reference internal" href="#loading-the-data">Loading the Data</a></li>
<li><a class="reference internal" href="#passing-the-data">Passing the Data</a><ul>
<li><a class="reference internal" href="#communication-via-the-neo4j-python-driver">Communication via the Neo4j Python Driver</a><ul>
<li><a class="reference internal" href="#interacting-with-a-running-neo4j-instance">Interacting with a running Neo4j instance</a></li>
<li><a class="reference internal" href="#exporting-for-the-neo4j-admin-import-feature">Exporting for the <cite>neo4j-admin import</cite> feature</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#usage-notes">Usage Notes</a></li>
<li><a class="reference internal" href="#submodule-documentation">Submodule documentation</a><ul>
<li><a class="reference internal" href="#module-biocypher.driver"><cite>driver.py</cite>: the BioCypher Neo4j Driver</a></li>
<li><a class="reference internal" href="#module-biocypher.check"><cite>check.py</cite>: BioCypher Format Data Representation and Consistency Checks</a></li>
<li><a class="reference internal" href="#module-biocypher.create"><cite>create.py</cite>: Base Classes for Node and Edge Representations in BioCypher</a></li>
<li><a class="reference internal" href="#module-biocypher.translate"><cite>translate.py</cite>: Translation Functionality for Implemented Types of Representation</a></li>
<li><a class="reference internal" href="#module-biocypher.write"><cite>write.py</cite>: Write the Graph to CSV Files for quick ‘admin import’</a></li>
<li><a class="reference internal" href="#module-biocypher.logger"><cite>logger.py</cite>: Logging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-tables-and-search">Indices, Tables, and Search</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">BioCypher</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <img alt="_images/biocypher-open-graph.png" src="_images/biocypher-open-graph.png" />
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h1>
<p>BioCypher is designed to serve as guideline and translation mechanism for both
the creation of property graph databases from primary data as well as for the
querying of these databases. The purpose is to combine the computational
power of graph databases with the search for answers of our most pressing
biological questions and facilitate interfacing with cutting edge developments
in the areas of causal reasoning, representation learning, and natural language
processing, all of which depend on having a consistent descriptive vocabulary.
To achieve meaningful automatic representations in the biomedical language
space, we include the <a class="reference external" href="https://biolink.github.io/biolink-model/">Biolink model</a>
as underlying hierarchical ontology, supplying identification, filtering, and
mapping capabilities. A side objective is the creation of human-readable graph
syntax.</p>
</section>
<section id="quickstart">
<h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline"></a></h1>
<p>The main interface for interacting with the BioCypher module to create your
own property graph consists of two components:</p>
<ol class="arabic simple">
<li><p>the <a class="reference internal" href="#host-module-adapter"><span class="std std-ref">host module adapter</span></a>, a python program, and</p></li>
<li><p>the <a class="reference internal" href="#schema-config"><span class="std std-ref">schema configuration file</span></a>, a YAML file.</p></li>
</ol>
<p>The adapter serves as a data interface between the source and BioCypher, piping
the “raw” data into BioCypher for the creation of the property graph, while the
schema configuration tells BioCypher how the graph should be structured,
detailing the names of constituents and how they should be connected.</p>
<section id="the-host-module-adapter">
<span id="host-module-adapter"></span><h2>The host module adapter<a class="headerlink" href="#the-host-module-adapter" title="Permalink to this headline"></a></h2>
<p>Currently, BioCypher expects input from the user module via an adapter module.
Throughout the tutorial, we will exemplarise the use of BioCypher using
<a class="reference external" href="https://omnipathdb.org">OmniPath</a> (more specifically, its infrastructural
backend, <a class="reference external" href="https://github.com/saezlab/pypath">PyPath</a>). The adapter
has the job of piping the data as it is represented in the original database
into the BioCypher input, for instance as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code> object of
single database entries, whether they be nodes or relationships in the graph
to be created. For more details, please refer to the example <a class="reference external" href="https://github.com/saezlab/pypath/blob/master/src/pypath/biocypher/adapter.py">PyPath adapter</a>
and the section on <a class="reference internal" href="#adapter"><span class="std std-ref">adapter functions</span></a>.</p>
</section>
<section id="the-schema-configuration-yaml-file">
<span id="schema-config"></span><h2>The schema configuration YAML file<a class="headerlink" href="#the-schema-configuration-yaml-file" title="Permalink to this headline"></a></h2>
<p>The second important component of translation into a BioCypher-compatible
property graph is the specification of graph constituents and their mode of
representation in the graph. For instance, we want to add a representation for
proteins to the OmniPath graph, and the proteins should be represented as
nodes. To make this known to the BioCypher module, we use the
<a class="reference external" href="https://github.com/saezlab/BioCypher/blob/main/config/schema_config.yaml">schema-config.yaml</a>,
which details <em>only</em> the immediate constituents of the desired graph. The
naming of these constituents must be equal to the ontological category of
the entity in the Biolink schema. The ontological category (or class) of
proteins in Biolink is simply <a class="reference external" href="https://biolink.github.io/biolink-model/docs/Protein.html">Protein</a>.
However, for more complex concepts, such as - for instance - pairwise
molecular interactions, the naming must also be consistent; in this case,
<a class="reference external" href="https://biolink.github.io/biolink-model/docs/PairwiseMolecularInteraction.html">PairwiseMolecularInteraction</a>.
Similarly, if translation functionality between identifiers is desired, the
identifier used for the class of graph entity must be consistent with the one
used in the Biolink specification. For proteins, this can be <code class="docutils literal notranslate"><span class="pre">UniProtKB</span></code>
(but not, for instance, <code class="docutils literal notranslate"><span class="pre">UniProt</span></code> or <code class="docutils literal notranslate"><span class="pre">uniprot</span></code>). For ease of access, we provide
a standard yaml file with the most common graph constituents and identifiers,
with the following basic structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Protein</span><span class="p">:</span>

   <span class="n">represented_as</span><span class="p">:</span> <span class="n">node</span>

   <span class="n">preferred_id</span><span class="p">:</span> <span class="n">UniProtKB</span>

   <span class="n">label_in_input</span><span class="p">:</span> <span class="n">protein</span>
</pre></div>
</div>
<p>In the protein case, we are specifying its representation as a node, that we
wish to use the UniProt identifier as the main identifier for proteins (the
Biolink designation for UniProt identifiers is <code class="docutils literal notranslate"><span class="pre">UniProtKB</span></code>), and that proteins
in the input coming from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> carry the label <code class="docutils literal notranslate"><span class="pre">protein</span></code> (in lower-case).</p>
<p>The other slots of a graph constituent entry contain information BioCypher
needs to receive the input data correctly and construct the graph accordingly.
For “Named Thing” entities such as the protein, this includes the mode of
representation (YAML entry <code class="docutils literal notranslate"><span class="pre">represented_as</span></code>), which can be <code class="docutils literal notranslate"><span class="pre">node</span></code> or <code class="docutils literal notranslate"><span class="pre">edge</span></code>.
Proteins can only feasibly represented as nodes, but for other entities, such
as interactions or aggregates, representation can be both as node or as edge.
In Biolink, these belong to the super-class
<a class="reference external" href="https://biolink.github.io/biolink-model/docs/associations.html">Associations</a>.
For associations, BioCypher additionally requires the specification of the
source and target of the association; for instance, a post-translational
interaction occurs between proteins, so the source and target attribute in the
<code class="docutils literal notranslate"><span class="pre">schema-config.yaml</span></code> will both be <code class="docutils literal notranslate"><span class="pre">Protein</span></code>. Again, these should adhere to the
naming scheme of Biolink.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PostTranslationalInteraction</span><span class="p">:</span>

   <span class="n">represented_as</span><span class="p">:</span> <span class="n">node</span>

   <span class="n">preferred_id</span><span class="p">:</span> <span class="n">concat_ids</span>

   <span class="n">source</span><span class="p">:</span> <span class="n">Protein</span>

   <span class="n">target</span><span class="p">:</span> <span class="n">Protein</span>

   <span class="n">label_in_input</span><span class="p">:</span> <span class="n">post_translational</span>

   <span class="n">label_as_edge</span><span class="p">:</span> <span class="n">INTERACTS_POST_TRANSLATIONAL</span>
</pre></div>
</div>
<p>For the post-translational interaction, which is an association, we are
specifying representation as a node (prompting BioCypher to create not only
the node but also two edges connecting to the proteins participating in any
particular post-translational interaction). Since there are no systematic
identifiers for post-translational interactions, we concatenate the protein
ids and relevant properties of the interaction to a new unique id
(arbitrarily named <code class="docutils literal notranslate"><span class="pre">concat_ids</span></code>). Note that BioCypher accepts non-Biolink IDs
since not all possible entries possess a systematic identifier system, whereas
the entity class (<code class="docutils literal notranslate"><span class="pre">Protein</span></code>, <code class="docutils literal notranslate"><span class="pre">PostTranslationalInteraction</span></code>) has to be
included in the Biolink schema and spelled identically. For this reason, we
<a class="reference internal" href="#biolink"><span class="std std-ref">extend the Biolink schema</span></a> in cases where there exists no entry
for our entity of choice.</p>
<p>Further, we are specifying the source and target classes of our association
(both <code class="docutils literal notranslate"><span class="pre">Protein</span></code>), the label we provide in the input from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code>
(<code class="docutils literal notranslate"><span class="pre">post_translational</span></code>), and - optionally - the label we would want the edge
in the graph to carry would the association be represented as an edge. This
has no bearing on the current example, where we choose representation as a
node, but is important for edge representation, as by consensus, property
graph edges are represented in all upper case form and as verbs, to distinguish
from nodes that are represented in PascalCase and as nouns.</p>
<section id="the-biolink-model-extension">
<span id="biolink"></span><h3>The Biolink model extension<a class="headerlink" href="#the-biolink-model-extension" title="Permalink to this headline"></a></h3>
</section>
</section>
</section>
<section id="the-adapter">
<span id="adapter"></span><h1>The Adapter<a class="headerlink" href="#the-adapter" title="Permalink to this headline"></a></h1>
<p>The adapter is a python program (in the case of <code class="docutils literal notranslate"><span class="pre">PyPath</span></code>, a submodule)
responsible for piping the data that is to be represented in the graph into
BioCypher in a somewhat arbitrary format. In our example, the adapter performs
three main functions (with functions 2 and 3 being mutually optional):</p>
<ol class="arabic simple">
<li><p>Load the <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> data python object to be transferred to BioCypher</p></li>
<li><p>Pass the data to BioCypher as a stream or list to be written to the Neo4j
database via the python driver (“online”)</p></li>
<li><p>Pass the data to BioCypher as a stream or list to be written to the Neo4j
database via admin import (batch import from CSV)</p></li>
</ol>
<section id="loading-the-data">
<h2>Loading the Data<a class="headerlink" href="#loading-the-data" title="Permalink to this headline"></a></h2>
<p>Depending on the data source, it is up to the user to find and define a
suitable representation to be piped into BioCypher. The way we handle it in
<code class="docutils literal notranslate"><span class="pre">PyPath</span></code> is only one of many: we load the entire <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> object into memory, to
be passed to BioCypher using a generator that evaluates each <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> object
and transforms it to the tuple representation below. This is made possible
by the already standardised form in which the data is represented within
<code class="docutils literal notranslate"><span class="pre">PyPath</span></code>. For more heterogeneous data representations, additional transformations
may be necessary before piping into BioCypher.</p>
</section>
<section id="passing-the-data">
<h2>Passing the Data<a class="headerlink" href="#passing-the-data" title="Permalink to this headline"></a></h2>
<p>In the <a class="reference external" href="https://github.com/saezlab/pypath/blob/fc4c959c168ce80427189f8dd237308707594ad0/src/pypath/biocypher/adapter.py#L189">pypath example</a>,
we are using <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code>-type objects to pass an unordered collection
of <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> contents into BioCypher. For nodes, we are specifying for each object
an ID and label (corresponding to its unique preferred identifier and its
ontological class), as well as a dictionary of arbitrary properties, each entry
as a 3-tuple. For relationships, the same applies, except that we are passing
two IDs, for source and target entities, which results in a 4-tuple.</p>
<p>Currently, there are two modes of interaction with the graph database
implemented in BioCypher. The first takes place via the Neo4j python driver,
which is either loaded by BioCypher or passed from the host module. The second
generates CSV files containing node and edge data in a standardised and
safety-checked format to be used with the <code class="docutils literal notranslate"><span class="pre">admin</span> <span class="pre">import</span></code> functionality of
Neo4j. Safety checks are important here because Neo4j does not guarantee
consistency of the resulting graph when using this feature; on the upside,
this mode of communication is much faster. However, it can only be used when
creating a new graph, not for changing an already existing one.</p>
<section id="communication-via-the-neo4j-python-driver">
<h3>Communication via the Neo4j Python Driver<a class="headerlink" href="#communication-via-the-neo4j-python-driver" title="Permalink to this headline"></a></h3>
<p>The BioCypher <a class="reference internal" href="#driver"><span class="std std-ref">Driver</span></a> is the main submodule of BioCypher. It
establishes a connection with a running graph database via the
<code class="xref py py-class docutils literal notranslate"><span class="pre">neo4j.GraphDatabase.driver</span></code>, integrates the funtions of the other
submodules, and serves as outside interface of BioCypher. This is the main
class that should be interacted with in the host module’s adapter class. It
handles authentification and basic database management as well as the creation
and manipulation of graph entries.</p>
<p>In our example, it is instantiated in the initialisation of the adapter, and
then called on for <a class="reference internal" href="#running"><span class="std std-ref">interacting with a running graph</span></a> and for
exporting a complete database in CSV format for the
<a class="reference internal" href="#admin-import"><span class="std std-ref">neo4j-admin import feature</span></a>.</p>
<section id="interacting-with-a-running-neo4j-instance">
<span id="running"></span><h4>Interacting with a running Neo4j instance<a class="headerlink" href="#interacting-with-a-running-neo4j-instance" title="Permalink to this headline"></a></h4>
<p>(via <cite>add_nodes()</cite> and <cite>add_edges()</cite>)</p>
</section>
<section id="exporting-for-the-neo4j-admin-import-feature">
<span id="admin-import"></span><h4>Exporting for the <cite>neo4j-admin import</cite> feature<a class="headerlink" href="#exporting-for-the-neo4j-admin-import-feature" title="Permalink to this headline"></a></h4>
<p>(via <cite>write_nodes()</cite> and <cite>write_edges()</cite>)</p>
</section>
</section>
</section>
</section>
<section id="usage-notes">
<h1>Usage Notes<a class="headerlink" href="#usage-notes" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p>A graph database can be built from any arbitrary collection of biomedical
data. We here examplarise the building of a biological prior knowledge graph
from the OmniPath database (Türei et al. 2021), but BioCypher includes the
extensive translation functionality from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> to accommodate custom
requirements for graph database contents.</p></li>
<li><p>A BioCypher graph has to be instantiated as such from the beginning, an
existing property graph cannot currently be “updated” to conform to the
BioCypher format.</p></li>
<li><p>As a first step, an empty Neo4j database has to be created and started; the
Python database driver can then be established either through BioCypher
directly or on the user’s end and passed to BioCypher (if there is greater
need for data security in authentication).</p></li>
<li><p>After the database driver has been passed to BioCypher, a new database can
be established given the selected data structure, to be determined in the
primary configuration file. In this step, all constraints and indices are
set to conform to the selected database structure. These can also be
modified afterwards.</p>
<ul>
<li><p>Note: if the database to be created is very extensive, BioCypher offers a
“secure export” method to create CSV files that can be used to instantiate
a new graph database very quickly using the <a class="reference external" href="https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/">Admin Import</a>
feature of Neo4j.</p></li>
</ul>
</li>
<li><p>The database structure and version are recorded in a meta-graph that serves as
a versioning system and simultaneously as a means of transmitting information
about the graph structure for the case of re-loading an existing database for
updating it with new information.</p></li>
</ul>
</section>
<section id="submodule-documentation">
<h1>Submodule documentation<a class="headerlink" href="#submodule-documentation" title="Permalink to this headline"></a></h1>
<section id="module-biocypher.driver">
<span id="driver-py-the-biocypher-neo4j-driver"></span><span id="driver"></span><h2><cite>driver.py</cite>: the BioCypher Neo4j Driver<a class="headerlink" href="#module-biocypher.driver" title="Permalink to this headline"></a></h2>
<p>This module handles the passing of a Neo4j driver from the client to
BioCypher and the modification of the database structure. It is part of
the BioCypher python package, homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<p>Todo:</p>
<dl class="py class">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.driver.</span></span><span class="sig-name descname"><span class="pre">BaseDriver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">driver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_uri</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neo4j://localhost:7687'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_auth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fetch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/config/db_config.yaml'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wipe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment_version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver" title="Permalink to this definition"></a></dt>
<dd><p>Manages the connection to the Neo4j server. Establishes the
connection and executes queries. A wrapper around the <cite>Driver</cite>
object from the <code class="xref py py-mod docutils literal notranslate"><span class="pre">neo4j</span></code> module, which is stored in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">driver</span></code> attribute.</p>
<dl class="simple">
<dt>The connection can be defined in three ways:</dt><dd><ul class="simple">
<li><p>Providing a ready <code class="docutils literal notranslate"><span class="pre">neo4j.Driver</span></code> instance</p></li>
<li><p>By URI and authentication data</p></li>
<li><p>By a YAML config file</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver</strong> (<em>neo4j.Driver</em>) – A <code class="docutils literal notranslate"><span class="pre">neo4j.Driver</span></code> instance, created by,
for example, <code class="docutils literal notranslate"><span class="pre">neo4j.GraphDatabase.driver</span></code>.</p></li>
<li><p><strong>db_name</strong> (<em>str</em>) – Name of the database (Neo4j graph) to use.</p></li>
<li><p><strong>db_uri</strong> (<em>str</em>) – Protocol, host and port to access the Neo4j
server.</p></li>
<li><p><strong>db_auth</strong> (<em>tuple</em>) – Neo4j server authentication data: tuple of user
name and password.</p></li>
<li><p><strong>fetch_size</strong> (<em>int</em>) – Optional; the fetch size to use in database
transactions.</p></li>
<li><p><strong>config_file</strong> (<em>str</em>) – Path to a YAML config file which provides the
URI, user name and password.</p></li>
<li><p><strong>wipe</strong> (<em>bool</em>) – Wipe the database after connection, ensuring the
data is loaded into an empty database.</p></li>
<li><p><strong>increment_version</strong> (<em>bool</em>) – Whether to increase version number
automatically and create a new BioCypher version node in the
graph.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.close" title="Permalink to this definition"></a></dt>
<dd><p>Closes the Neo4j driver if it exists and is open.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.create_db">
<span class="sig-name descname"><span class="pre">create_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.create_db" title="Permalink to this definition"></a></dt>
<dd><p>Create a database if it does not already exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the database.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.current_db">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_db</span></span><a class="headerlink" href="#biocypher.driver.BaseDriver.current_db" title="Permalink to this definition"></a></dt>
<dd><p>Name of the database (graph) where the next query would be
executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Name of a database.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(str)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.db_connect">
<span class="sig-name descname"><span class="pre">db_connect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.db_connect" title="Permalink to this definition"></a></dt>
<dd><p>Creates a database connection manager (driver) based on the
current configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.db_exists">
<span class="sig-name descname"><span class="pre">db_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.db_exists" title="Permalink to this definition"></a></dt>
<dd><p>Tells if a database exists in the storage of the Neo4j server.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of a database (graph).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if the database exists.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.db_online">
<span class="sig-name descname"><span class="pre">db_online</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.db_online" title="Permalink to this definition"></a></dt>
<dd><p>Tells if a database is currently online (active).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of a database (graph).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if the database is online.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.db_status">
<span class="sig-name descname"><span class="pre">db_status</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'currentStatus'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.db_status" title="Permalink to this definition"></a></dt>
<dd><p>Tells the current status or other state info of a database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of a database (graph).</p></li>
<li><p><strong>field</strong> (<em>str</em><em>,</em><em>NoneType</em>) – The field to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The status as a string, <cite>None</cite> if the database
does not exist. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">field</span></code> is <cite>None</cite> a
dictionary with all fields will be returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(str,dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.drop_db">
<span class="sig-name descname"><span class="pre">drop_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.drop_db" title="Permalink to this definition"></a></dt>
<dd><p>Deletes a database if it exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the database.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.edge_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edge_count</span></span><a class="headerlink" href="#biocypher.driver.BaseDriver.edge_count" title="Permalink to this definition"></a></dt>
<dd><p>Number of edges in the database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.ensure_db">
<span class="sig-name descname"><span class="pre">ensure_db</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.ensure_db" title="Permalink to this definition"></a></dt>
<dd><p>Makes sure the database used by this instance exists and is
online. If the database creation or startup is necessary but the
user does not have the sufficient privileges, an exception will
be raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.explain">
<span class="sig-name descname"><span class="pre">explain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fetch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.explain" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for EXPLAIN function query to bring summary in
readable form.</p>
<p>CAVE: Only handles linear profiles (no branching) as of now.
TODO include branching as in profile()</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.node_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node_count</span></span><a class="headerlink" href="#biocypher.driver.BaseDriver.node_count" title="Permalink to this definition"></a></dt>
<dd><p>Number of nodes in the database.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.profile">
<span class="sig-name descname"><span class="pre">profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fetch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.profile" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for PROFILE function query to bring summary in
readable form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>query</strong> (<em>str</em>) – a valid Cypher query (see <a class="reference internal" href="#biocypher.driver.BaseDriver.query" title="biocypher.driver.BaseDriver.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a>)</p></li>
<li><p><strong>db</strong> (<em>str</em>) – the DB inside the Neo4j server that should be queried</p></li>
<li><p><strong>fetch_size</strong> (<em>int</em>) – the Neo4j fetch size parameter</p></li>
<li><p><strong>write</strong> (<em>bool</em>) – indicates whether to address write- or read-
servers</p></li>
<li><p><strong>explain</strong> (<em>bool</em>) – indicates whether to <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> the CYPHER
query and return the ResultSummary</p></li>
<li><p><strong>explain</strong> – indicates whether to <code class="docutils literal notranslate"><span class="pre">PROFILE</span></code> the CYPHER
query and return the ResultSummary</p></li>
<li><p><strong>**kwargs</strong> – optional objects used in CYPHER interactive mode,
for instance for passing a parameter dictionary</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>dict: the raw profile returned by the Neo4j bolt driver</p></li>
<li><p>list of str: a list of strings ready for printing</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.query">
<span class="sig-name descname"><span class="pre">query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fetch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.query" title="Permalink to this definition"></a></dt>
<dd><p>Creates a session with the driver passed into the class at
instantiation, runs a CYPHER query and returns the response.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>query</strong> (<em>str</em>) – a valid CYPHER query, can include APOC if the APOC
plugin is installed in the accessed database</p></li>
<li><p><strong>db</strong> (<em>str</em>) – the DB inside the Neo4j server that should be queried</p></li>
<li><p><strong>fetch_size</strong> (<em>int</em>) – the Neo4j fetch size parameter</p></li>
<li><p><strong>write</strong> (<em>bool</em>) – indicates whether to address write- or read-
servers</p></li>
<li><p><strong>explain</strong> (<em>bool</em>) – indicates whether to EXPLAIN the CYPHER
query and return the ResultSummary</p></li>
<li><p><strong>explain</strong> – indicates whether to PROFILE the CYPHER
query and return the ResultSummary</p></li>
<li><p><strong>**kwargs</strong> – optional objects used in CYPHER interactive mode,
for instance for passing a parameter dictionary</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>neo4j.Record.data: the Neo4j response to the query, consumed
by the shorthand <code class="docutils literal notranslate"><span class="pre">.data()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Result</span></code> object</p></li>
<li><p>neo4j.ResultSummary: information about the result returned
by the <code class="docutils literal notranslate"><span class="pre">.consume()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Result</span></code> object</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.read_config">
<span class="sig-name descname"><span class="pre">read_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.read_config" title="Permalink to this definition"></a></dt>
<dd><p>Populates the instance configuration from one section of a YAML
config file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.reload">
<span class="sig-name descname"><span class="pre">reload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.reload" title="Permalink to this definition"></a></dt>
<dd><p>Reloads the object from the module level.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.start_db">
<span class="sig-name descname"><span class="pre">start_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.start_db" title="Permalink to this definition"></a></dt>
<dd><p>Starts a database (brings it online) if it is offline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the database.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.stop_db">
<span class="sig-name descname"><span class="pre">stop_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.stop_db" title="Permalink to this definition"></a></dt>
<dd><p>Stops a database, making sure it’s offline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the database.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.user">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user</span></span><a class="headerlink" href="#biocypher.driver.BaseDriver.user" title="Permalink to this definition"></a></dt>
<dd><p>User for the currently active connection.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The name of the user, <cite>None</cite> if no connection or no
unencrypted authentication data is available.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(str)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.BaseDriver.wipe_db">
<span class="sig-name descname"><span class="pre">wipe_db</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.BaseDriver.wipe_db" title="Permalink to this definition"></a></dt>
<dd><p>Used in initialisation, deletes all nodes and edges and drops
all constraints.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biocypher.driver.Driver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.driver.</span></span><span class="sig-name descname"><span class="pre">Driver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">driver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_uri</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neo4j://localhost:7687'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_auth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fetch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/config/module_config.yaml'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wipe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment_version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver" title="Permalink to this definition"></a></dt>
<dd><p>Manages a connection to a biocypher database.</p>
<dl class="simple">
<dt>The connection can be defined in three ways:</dt><dd><ul class="simple">
<li><p>Providing a ready <code class="docutils literal notranslate"><span class="pre">neo4j.Driver</span></code> instance</p></li>
<li><p>By URI and authentication data</p></li>
<li><p>By a YAML config file</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>driver</strong> (<em>neo4j.Driver</em>) – A <code class="docutils literal notranslate"><span class="pre">neo4j.Driver</span></code> instance, created by,
for example, <code class="docutils literal notranslate"><span class="pre">neo4j.GraphDatabase.driver</span></code>.</p></li>
<li><p><strong>db_name</strong> (<em>str</em>) – Name of the database (Neo4j graph) to use.</p></li>
<li><p><strong>db_uri</strong> (<em>str</em>) – Protocol, host and port to access the Neo4j
server.</p></li>
<li><p><strong>db_auth</strong> (<em>tuple</em>) – Neo4j server authentication data: tuple of user
name and password.</p></li>
<li><p><strong>fetch_size</strong> (<em>int</em>) – Optional; the fetch size to use in database
transactions.</p></li>
<li><p><strong>config_file</strong> (<em>str</em>) – Path to a YAML config file which provides the
URI, user name and password.</p></li>
<li><p><strong>wipe</strong> (<em>bool</em>) – Wipe the database after connection, ensuring the
data is loaded into an empty database.</p></li>
<li><p><strong>increment_version</strong> (<em>bool</em>) – Whether to increase version number
automatically and create a new BioCypher version node in the
graph.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.add_biocypher_edges">
<span class="sig-name descname"><span class="pre">add_biocypher_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.add_biocypher_edges" title="Permalink to this definition"></a></dt>
<dd><p>Accepts an edge type handoff class
(<a class="reference internal" href="#biocypher.create.BioCypherEdge" title="biocypher.create.BioCypherEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherEdge</span></code></a>) with source
and target ids, label, and a dict of properties (passing on the
type of property, ie, int, string …).</p>
<p>The individual edge is either passed as a singleton, in the case
of representation as an edge in the graph, or as a 4-tuple, in
the case of representation as a node (with two edges connecting
to interaction partners).</p>
<p>The dict retrieved by the
<a class="reference internal" href="#biocypher.create.BioCypherEdge.get_dict" title="biocypher.create.BioCypherEdge.get_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.create.BioCypherEdge.get_dict()</span></code></a> method is
passed into Neo4j as a map of maps, explicitly encoding source
and target ids and the relationship label, and adding all edge
properties from the ‘properties’ key of the dict. The merge is
performed via APOC, matching only on source and target id to
prevent duplicates. The same properties are set on match and on
create, irrespective of the actual event.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> – a list of <a class="reference internal" href="#biocypher.create.BioCypherEdge" title="biocypher.create.BioCypherEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherEdge</span></code></a> objects</p></li>
<li><p><strong>explain</strong> (<em>bool</em>) – whether to call <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> in front of the
CYPHER query</p></li>
<li><p><strong>profile</strong> (<em>bool</em>) – whether to call <code class="docutils literal notranslate"><span class="pre">PROFILE</span></code> in front of the
CYPHER query</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.add_biocypher_nodes">
<span class="sig-name descname"><span class="pre">add_biocypher_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.add_biocypher_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Accepts a node type handoff class
(<a class="reference internal" href="#biocypher.create.BioCypherNode" title="biocypher.create.BioCypherNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherNode</span></code></a>) with id,
label, and a dict of properties (passing on the type of
property, ie, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, …).</p>
<p>The dict retrieved by the
<a class="reference internal" href="#biocypher.create.BioCypherNode.get_dict" title="biocypher.create.BioCypherNode.get_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">biocypher.create.BioCypherNode.get_dict()</span></code></a> method is
passed into Neo4j as a map of maps, explicitly encoding node id
and label, and adding all other properties from the ‘properties’
key of the dict. The merge is performed via APOC, matching only
on node id to prevent duplicates. The same properties are set on
match and on create, irrespective of the actual event.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>iterable of BioCypherNode</em>) – a list of
<a class="reference internal" href="#biocypher.create.BioCypherNode" title="biocypher.create.BioCypherNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherNode</span></code></a> objects</p></li>
<li><p><strong>explain</strong> (<em>bool</em>) – whether to call <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> in front of the
CYPHER query</p></li>
<li><p><strong>profile</strong> (<em>bool</em>) – whether to call <code class="docutils literal notranslate"><span class="pre">PROFILE</span></code> in front of the
CYPHER query</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.add_edges">
<span class="sig-name descname"><span class="pre">add_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_tar_type_tuples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.add_edges" title="Permalink to this definition"></a></dt>
<dd><p>Generic edge adder method to add any kind of input to the
graph via the <a class="reference internal" href="#biocypher.create.BioCypherEdge" title="biocypher.create.BioCypherEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherEdge</span></code></a> class.
Employs translation functionality and calls the
<a class="reference internal" href="#biocypher.driver.Driver.add_biocypher_edges" title="biocypher.driver.Driver.add_biocypher_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_biocypher_edges()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>id_type_tuples</strong> (<em>iterable of 4-tuple</em>) – for each edge to add to
the biocypher graph, a 4-tuple with the following layout:
first and second, the (unique if constrained) IDs of the
source and target nodes of the relationship; third, the
type of the relationship, all caps with underscores and
in verb form (Neo4j primary label, eg <cite>:IS_TARGET_OF</cite>);
and fourth, a dictionary of arbitrary properties the edge
should possess (can be empty).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>the query result of <a class="reference internal" href="#biocypher.driver.Driver.add_biocypher_edges" title="biocypher.driver.Driver.add_biocypher_edges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_biocypher_edges()</span></code></a></dt><dd><ul class="simple">
<li><p>first entry: data</p></li>
<li><p>second entry: Neo4j summary.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.add_nodes">
<span class="sig-name descname"><span class="pre">add_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_type_tuples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.add_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Generic node adder method to add any kind of input to the
graph via the <a class="reference internal" href="#biocypher.create.BioCypherNode" title="biocypher.create.BioCypherNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherNode</span></code></a> class. Employs translation
functionality and calls the <a class="reference internal" href="#biocypher.driver.Driver.add_biocypher_nodes" title="biocypher.driver.Driver.add_biocypher_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_biocypher_nodes()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>id_type_tuples</strong> (<em>iterable of 3-tuple</em>) – for each node to add to
the biocypher graph, a 3-tuple with the following layout:
first, the (unique if constrained) ID of the node; second, the
type of the node, capitalised or PascalCase and in noun form
(Neo4j primary label, eg <cite>:Protein</cite>); and third, a dictionary
of arbitrary properties the node should possess (can be empty).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>the query result of <a class="reference internal" href="#biocypher.driver.Driver.add_biocypher_nodes" title="biocypher.driver.Driver.add_biocypher_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_biocypher_nodes()</span></code></a></dt><dd><ul class="simple">
<li><p>first entry: data</p></li>
<li><p>second entry: Neo4j summary.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.get_import_call">
<span class="sig-name descname"><span class="pre">get_import_call</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.get_import_call" title="Permalink to this definition"></a></dt>
<dd><p>Upon using the batch writer for writing admin import CSV files,
return a string containing the neo4j admin import call with
delimiters, database name, and paths of node and edge files.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a neo4j-admin import call</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.init_db">
<span class="sig-name descname"><span class="pre">init_db</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.init_db" title="Permalink to this definition"></a></dt>
<dd><p>Used to initialise a property graph database by deleting
contents and constraints and setting up new constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.write_edges">
<span class="sig-name descname"><span class="pre">write_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.write_edges" title="Permalink to this definition"></a></dt>
<dd><p>Write BioCypher edges to disk using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">write</span></code> module,
formatting the CSV to enable Neo4j admin import from the target
directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edges</strong> (<em>iterable</em>) – collection of edges to be written in
BioCypher-compatible CSV format; can be any compatible
(ie, translatable) input format or already as
<a class="reference internal" href="#biocypher.create.BioCypherEdge" title="biocypher.create.BioCypherEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherEdge</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.write_import_call">
<span class="sig-name descname"><span class="pre">write_import_call</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.write_import_call" title="Permalink to this definition"></a></dt>
<dd><p>Upon using the batch writer for writing admin import CSV files,
write a string containing the neo4j admin import call with
delimiters, database name, and paths of node and edge files, to
the export directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.driver.Driver.write_nodes">
<span class="sig-name descname"><span class="pre">write_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.driver.Driver.write_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Write BioCypher nodes to disk using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">write</span></code> module,
formatting the CSV to enable Neo4j admin import from the target
directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nodes</strong> (<em>iterable</em>) – collection of nodes to be written in
BioCypher-compatible CSV format; can be any compatible
(ie, translatable) input format or already as
<a class="reference internal" href="#biocypher.create.BioCypherNode" title="biocypher.create.BioCypherNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.create.BioCypherNode</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-biocypher.check">
<span id="check-py-biocypher-format-data-representation-and-consistency-checks"></span><h2><cite>check.py</cite>: BioCypher Format Data Representation and Consistency Checks<a class="headerlink" href="#module-biocypher.check" title="Permalink to this headline"></a></h2>
<p>This module is used for assessing a Neo4j instance for compliance with
the BioCypher standard and returning pass/fail, and, in the event of
“pass”, it returns the primary identifiers chosen by the user of the
active database to be used in translation of the input data to the
correct format required for the active database. It is part of the
BioCypher python package, homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<dl class="py class">
<dt class="sig sig-object py" id="biocypher.check.MetaEdge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.check.</span></span><span class="sig-name descname"><span class="pre">MetaEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relationship_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CONTAINS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.MetaEdge" title="Permalink to this definition"></a></dt>
<dd><p>Graph structure information edge in the meta-graph. Inherits from
BioCypherNode but fixes label to “:CONTAINS”.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biocypher.check.MetaNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.check.</span></span><span class="sig-name descname"><span class="pre">MetaNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MetaNode'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.MetaNode" title="Permalink to this definition"></a></dt>
<dd><p>Graph structure information node representing node type entities in
the BioCypher graph. Inherits from BioCypherNode but fixes label to
“:MetaNode”. Is connected to VersionNode via “:CONTAINS”
relationship.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biocypher.check.VersionNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.check.</span></span><span class="sig-name descname"><span class="pre">VersionNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bcy_driver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BioCypher'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.VersionNode" title="Permalink to this definition"></a></dt>
<dd><p>Versioning and graph structure information meta node. Inherits from
BioCypherNode but fixes label to “:BioCypher” and sets version
by using the current date and time (meaning it overrides both
mandatory args from BioCypherNode).</p>
<p>Is created upon establishment of connection with the database and
remains fixed for each BioCypher “session” (ie, the entire duration
from starting the connection to the termination of the BioCypher
adapter instance). Is connected to MetaNodes and MetaEdges via
“:CONTAINS” relationships.</p>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.check.VersionNode.get_current_id">
<span class="sig-name descname"><span class="pre">get_current_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.VersionNode.get_current_id" title="Permalink to this definition"></a></dt>
<dd><p>Instantiate a version ID for the current session. For now does
versioning using datetime.</p>
<p>Can later implement incremental versioning, versioning from
config file, or manual specification via argument.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.check.VersionNode.get_graph_schema">
<span class="sig-name descname"><span class="pre">get_graph_schema</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.VersionNode.get_graph_schema" title="Permalink to this definition"></a></dt>
<dd><p>Return graph schema information from meta graph if it exists, or
create new schema information properties from configuration
file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.check.VersionNode.get_graph_state">
<span class="sig-name descname"><span class="pre">get_graph_state</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.VersionNode.get_graph_state" title="Permalink to this definition"></a></dt>
<dd><p>Check in active DBMS connection for existence of VersionNodes,
return the most recent VersionNode as representation of the
graph state. If no VersionNode found, assume blank graph state
and initialise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.check.VersionNode.get_leaves">
<span class="sig-name descname"><span class="pre">get_leaves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.check.VersionNode.get_leaves" title="Permalink to this definition"></a></dt>
<dd><p>Get leaves of the tree hierarchy from the data structure dict
contained in the <cite>schema_config.yaml</cite>. Serves no purpose
currently since the decision to have the <cite>schema_config.yaml</cite>
represent only the direct constituents of the desired graph and
not the complete hierarchy any more; this will be derived from
the (modified) Biolink model. Now only does filtering of the
schema for entities that have a “represented_as” property.</p>
<p>Will leave in since the “leaves” are a nice visual cue for the
hierarchical representation of graph constituents.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-biocypher.create">
<span id="create-py-base-classes-for-node-and-edge-representations-in-biocypher"></span><h2><cite>create.py</cite>: Base Classes for Node and Edge Representations in BioCypher<a class="headerlink" href="#module-biocypher.create" title="Permalink to this headline"></a></h2>
<p>This module is used for the creating a generic property graph database
for use in biomedical research applications. It takes as inputs ordered
collections of biomedical nodes and relationships and yields specific
classes for property graph nodes and edges that adhere to the BioCypher
standard. It is part of the BioCypher python package, homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<dl class="py class">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.create.</span></span><span class="sig-name descname"><span class="pre">BioCypherEdge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relationship_label</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge" title="Permalink to this definition"></a></dt>
<dd><p>Handoff class to represent biomedical relationships in Neo4j.</p>
<p>Has source and target ids, label, property dict; ids and label (in
the Neo4j sense of a label, ie, the entity descriptor after the
colon, such as “:TARGETS”) are non-optional and called source_id,
target_id, and relationship_label to avoid confusion with properties
called “label”, which usually denotes the human-readable form.
Relationship labels are written in UPPERCASE and as verbs, as per
Neo4j consensus.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_id</strong> (<em>string</em>) – consensus “best” id for
biological entity</p></li>
<li><p><strong>target_id</strong> (<em>string</em>) – consensus “best” id for
biological entity</p></li>
<li><p><strong>relationship_label</strong> (<em>string</em>) – type of interaction, UPPERCASE</p></li>
<li><p><strong>**properties</strong> (<em>kwargs</em>) – collection of all other properties to be
passed to Neo4j for the respective edge (dict)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge.get_dict">
<span class="sig-name descname"><span class="pre">get_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge.get_dict" title="Permalink to this definition"></a></dt>
<dd><p>Convert self to format accepted by Neo4j driver (Python dict -&gt;
Neo4j Map).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>source_id, target_id and relationship_label as</dt><dd><p>top-level key-value pairs, properties as second-level
dict.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge.get_label">
<span class="sig-name descname"><span class="pre">get_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge.get_label" title="Permalink to this definition"></a></dt>
<dd><p>Returns relationship label.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>relationship_label</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge.get_properties">
<span class="sig-name descname"><span class="pre">get_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge.get_properties" title="Permalink to this definition"></a></dt>
<dd><p>Returns all other relationship properties apart from primary ids
and label as key-value pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>properties</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge.get_source_id">
<span class="sig-name descname"><span class="pre">get_source_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge.get_source_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns primary node identifier of relationship source.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>source_id</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherEdge.get_target_id">
<span class="sig-name descname"><span class="pre">get_target_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherEdge.get_target_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns primary node identifier of relationship target.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>target_id</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.create.</span></span><span class="sig-name descname"><span class="pre">BioCypherNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode" title="Permalink to this definition"></a></dt>
<dd><p>Handoff class to represent biomedical entities as Neo4j nodes.</p>
<p>Has id, label, property dict; id and label (in the Neo4j sense of a
label, ie, the entity descriptor after the colon, such as
“:Protein”) are non-optional and called node_id and node_label to
avoid confusion with “label” properties. Node labels are written in
PascalCase and as nouns, as per Neo4j consensus.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>string</em>) – consensus “best” id for biological entity</p></li>
<li><p><strong>node_label</strong> (<em>string</em>) – primary type of entity, capitalised</p></li>
<li><p><strong>**properties</strong> (<em>kwargs</em>) – collection of all other properties to be
passed to neo4j for the respective node (dict)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode.get_all_labels">
<span class="sig-name descname"><span class="pre">get_all_labels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode.get_all_labels" title="Permalink to this definition"></a></dt>
<dd><p>Returns all labels, primary and optional.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>properties</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode.get_dict">
<span class="sig-name descname"><span class="pre">get_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode.get_dict" title="Permalink to this definition"></a></dt>
<dd><p>Convert self to format accepted by Neo4j driver (Python dict -&gt;
Neo4j Map).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>node_id and node_label as top-level key-value pairs,
properties as second-level dict.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode.get_id">
<span class="sig-name descname"><span class="pre">get_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode.get_id" title="Permalink to this definition"></a></dt>
<dd><p>Returns primary node identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>node_id</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode.get_label">
<span class="sig-name descname"><span class="pre">get_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode.get_label" title="Permalink to this definition"></a></dt>
<dd><p>Returns primary node label.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>node_label</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.create.BioCypherNode.get_properties">
<span class="sig-name descname"><span class="pre">get_properties</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherNode.get_properties" title="Permalink to this definition"></a></dt>
<dd><p>Returns all other node properties apart from primary id and
label as key-value pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>properties</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="biocypher.create.BioCypherRelAsNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.create.</span></span><span class="sig-name descname"><span class="pre">BioCypherRelAsNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.create.BioCypherRelAsNode" title="Permalink to this definition"></a></dt>
<dd><p>Class to represent relationships as nodes (with in- and outgoing
edges) as a triplet of a BioCypherNode and two BioCypherEdges. Main
usage in type checking (instances where the receiving function needs
to check whether it receives a relationship as a single edge or as
a triplet).</p>
</dd></dl>

</section>
<section id="module-biocypher.translate">
<span id="translate-py-translation-functionality-for-implemented-types-of-representation"></span><h2><cite>translate.py</cite>: Translation Functionality for Implemented Types of Representation<a class="headerlink" href="#module-biocypher.translate" title="Permalink to this headline"></a></h2>
<p>This module handles the lookup and storage of entity IDs that are part
of the BioCypher schema. It is part of the BioCypher python package,
homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<dl class="py class">
<dt class="sig sig-object py" id="biocypher.translate.BiolinkAdapter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.translate.</span></span><span class="sig-name descname"><span class="pre">BiolinkAdapter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">leaves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_yaml</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_yaml_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/config/biocypher-biolink-model.yaml'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.translate.BiolinkAdapter" title="Permalink to this definition"></a></dt>
<dd><p>Performs various functions to integrate the Biolink ontology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.translate.BiolinkAdapter.translate_leaves_to_biolink">
<span class="sig-name descname"><span class="pre">translate_leaves_to_biolink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">leaves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_yaml</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_yaml_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.translate.BiolinkAdapter.translate_leaves_to_biolink" title="Permalink to this definition"></a></dt>
<dd><p>Translates the leaves (direct constituents of the graph) given
in the <cite>schema_config.yaml</cite> to Biolink-conforming nomenclature.
Simultaneously get the structure in the form of the parents of
each leaf.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biocypher.translate.gen_translate_edges">
<span class="sig-prename descclassname"><span class="pre">biocypher.translate.</span></span><span class="sig-name descname"><span class="pre">gen_translate_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">leaves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_tar_type_tuples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.translate.gen_translate_edges" title="Permalink to this definition"></a></dt>
<dd><p>Translates input edge representation to a representation that
conforms to the schema of the given BioCypher graph. For now
requires explicit statement of edge type on pass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>leaves</strong> (<em>dict</em>) – dictionary detailing the leaves of the hierarchy
tree representing the structure of the graph; the leaves are
the entities that will be direct components of the graph,
while the intermediary nodes are additional labels for
filtering purposes.</p></li>
<li><p><strong>src_tar_type_tuples</strong> (<em>list of tuples</em>) – collection of tuples
representing source and target of an interaction via their
unique ids as well as the type of interaction in the
original database notation, which is translated to BioCypher
notation using the <cite>leaves</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biocypher.translate.gen_translate_nodes">
<span class="sig-prename descclassname"><span class="pre">biocypher.translate.</span></span><span class="sig-name descname"><span class="pre">gen_translate_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">leaves</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_type_tuples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.translate.gen_translate_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Translates input node representation to a representation that
conforms to the schema of the given BioCypher graph. For now
requires explicit statement of node type on pass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>leaves</strong> (<em>dict</em>) – dictionary detailing the leaves of the hierarchy
tree representing the structure of the graph; the leaves are
the entities that will be direct components of the graph,
while the intermediary nodes are additional labels for
filtering purposes.</p></li>
<li><p><strong>id_type_tuples</strong> (<em>list of tuples</em>) – collection of tuples
representing individual nodes by their unique id and a type
that is translated from the original database notation to
the corresponding BioCypher notation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="biocypher.translate.getpath">
<span class="sig-prename descclassname"><span class="pre">biocypher.translate.</span></span><span class="sig-name descname"><span class="pre">getpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nested_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.translate.getpath" title="Permalink to this definition"></a></dt>
<dd><p>Get specific value from unknown location in a nested dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nested_dict</strong> (<em>dict</em>) – the dict to search</p></li>
<li><p><strong>value</strong> – the dictionary value to find</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-biocypher.write">
<span id="write-py-write-the-graph-to-csv-files-for-quick-admin-import"></span><h2><cite>write.py</cite>: Write the Graph to CSV Files for quick ‘admin import’<a class="headerlink" href="#module-biocypher.write" title="Permalink to this headline"></a></h2>
<p>This module handles the configuration and disk writing of CSV files
intended for use with the Neo4J admin import function, to quickly
transfer large amounts of content into an unused database. For more
explanation, see <a class="reference external" href="https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/">https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/</a>. This module is part of the BioCypher python
package, homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<dl class="py class">
<dt class="sig sig-object py" id="biocypher.write.BatchWriter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">biocypher.write.</span></span><span class="sig-name descname"><span class="pre">BatchWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">schema</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bl_adapter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neo4j'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.write.BatchWriter" title="Permalink to this definition"></a></dt>
<dd><p>Class for writing node and edge representations to disk using the
format specified by Neo4j for the use of admin import. Each batch
writer instance has a fixed representation that needs to be passed
at instantiation via the <code class="xref py py-attr docutils literal notranslate"><span class="pre">schema</span></code> argument. The instance
also expects a biolink adapter via <code class="xref py py-attr docutils literal notranslate"><span class="pre">bl_adapter</span></code> to be able
to convert and extend the hierarchy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>schema</strong> (<em>dict</em>) – dictionary detailing the BioCypher graph schema
(from <code class="xref py py-class docutils literal notranslate"><span class="pre">VersionNode</span></code>)</p></li>
<li><p><strong>bl_adapter</strong> (<a class="reference internal" href="#biocypher.translate.BiolinkAdapter" title="biocypher.translate.BiolinkAdapter"><em>BiolinkAdapter</em></a>) – instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">BiolinkAdapter</span></code> to enable translation and
ontology queries</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="biocypher.write.BatchWriter.get_import_call">
<span class="sig-name descname"><span class="pre">get_import_call</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.write.BatchWriter.get_import_call" title="Permalink to this definition"></a></dt>
<dd><p>Function to return the import call detailing folder and
individual node and edge headers and data files, as well as
delimiters and database name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a bash command for neo4j-admin import</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.write.BatchWriter.write_edges">
<span class="sig-name descname"><span class="pre">write_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.write.BatchWriter.write_edges" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for writing edges and their headers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edges</strong> (<a class="reference internal" href="#biocypher.create.BioCypherEdge" title="biocypher.create.BioCypherEdge"><em>BioCypherEdge</em></a>) – a list or generator of edges in
<code class="xref py py-class docutils literal notranslate"><span class="pre">BioCypherEdge</span></code> format</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.write.BatchWriter.write_import_call">
<span class="sig-name descname"><span class="pre">write_import_call</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.write.BatchWriter.write_import_call" title="Permalink to this definition"></a></dt>
<dd><p>Function to write the import call detailing folder and
individual node and edge headers and data files, as well as
delimiters and database name, to the export folder as txt.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="biocypher.write.BatchWriter.write_nodes">
<span class="sig-name descname"><span class="pre">write_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.write.BatchWriter.write_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for writing nodes and their headers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nodes</strong> (<a class="reference internal" href="#biocypher.create.BioCypherNode" title="biocypher.create.BioCypherNode"><em>BioCypherNode</em></a>) – a list or generator of nodes in
<code class="xref py py-class docutils literal notranslate"><span class="pre">BioCypherNode</span></code> format</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The return value. True for success, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-biocypher.logger">
<span id="logger-py-logging"></span><h2><cite>logger.py</cite>: Logging<a class="headerlink" href="#module-biocypher.logger" title="Permalink to this headline"></a></h2>
<p>This module handles logging for the BioCypher the BioCypher python
package, homepage: TODO.</p>
<p>Copyright 2021, Heidelberg University Clinic</p>
<dl class="simple">
<dt>File author(s): Sebastian Lobentanzer</dt><dd><p>…</p>
</dd>
</dl>
<p>Distributed under GPLv3 license, see LICENSE.txt.</p>
<p>Todo:</p>
<dl class="py function">
<dt class="sig sig-object py" id="biocypher.logger.get_logger">
<span class="sig-prename descclassname"><span class="pre">biocypher.logger.</span></span><span class="sig-name descname"><span class="pre">get_logger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#biocypher.logger.get_logger" title="Permalink to this definition"></a></dt>
<dd><p>Main function of providing a logger instance to any module. Should
be called from each module separately, e.g., after imports, assign
<code class="docutils literal notranslate"><span class="pre">logger</span> <span class="pre">=</span> <span class="pre">get_logger(__name__)</span></code> to yield a module-specific logger
that can be used according to Python <code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code>.</p>
<p>The file handler creates a log file named after the current date and
time. Levels to output to file and console can be set here.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – name of the logger instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an instance of the Python <code class="xref py py-mod docutils literal notranslate"><span class="pre">Logger</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>logging.getLogger</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="indices-tables-and-search">
<h1>Indices, Tables, and Search<a class="headerlink" href="#indices-tables-and-search" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<div class="toctree-wrapper compound">
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Heidelberg University Clinic.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>