<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quickstart &mdash; BioCypher  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="BioCypher Tutorial - Basics" href="tutorial.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="contents.html" class="icon icon-home">
            BioCypher
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html#configuration">Configuration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-host-module-adapter">The host module adapter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-schema-configuration-yaml-file">The schema configuration YAML file</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-biolink-model-extension">The Biolink model extension</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">BioCypher Tutorial - Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-ontology.html">BioCypher Tutorial - Handling Ontologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapter.html">BioCypher Tutorial - Adapters</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapter.html#interacting-with-neo4j">Interacting with Neo4j</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html">BioCypher</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="contents.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quickstart</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quickstart.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quickstart">
<h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this heading"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you already know how BioCypher works, we provide here a quickstart into the
knowledge graph build process. We provide a template repository on GitHub, which
you can use to get started with your own project.  You can get it
<a class="reference external" href="https://github.com/saezlab/biocypher-project-template">here</a>.  To set up a new
project, simply follow the instructions in the README.</p>
<p>If you are new to BioCypher and would like a step-by-step introduction to the
package, please follow the <a class="reference internal" href="tutorial.html#tutorial"><span class="std std-ref">tutorial</span></a>.</p>
</div>
<p>The main interface for interacting with the BioCypher module to create
your own property graph consists of two components:</p>
<ol class="arabic simple">
<li><p>the <a class="reference internal" href="#qs-host-module-adapter"><span class="std std-ref">host module adapter</span></a>, a python
program, and</p></li>
<li><p>the <a class="reference internal" href="#qs-schema-config"><span class="std std-ref">schema configuration file</span></a>, a YAML file.</p></li>
</ol>
<p>The adapter serves as a data interface between the source and BioCypher,
piping the “raw” data into BioCypher for the creation of the property
graph, while the schema configuration tells BioCypher how the graph
should be structured, detailing the names of constituents and how they
should be connected.</p>
<section id="the-host-module-adapter">
<span id="qs-host-module-adapter"></span><h2>The host module adapter<a class="headerlink" href="#the-host-module-adapter" title="Permalink to this heading"></a></h2>
<p>Currently, BioCypher expects input from the user module via an adapter module.
The adapter has the job of piping the data as it is represented in the original
database into the BioCypher input, for instance as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code>
object of single database entries, whether they be nodes or relationships in the
graph to be created. Examples for current adapters can be found in several of
our ongoing projects and the section on <a class="reference internal" href="adapter.html#adapter-functions"><span class="std std-ref">adapter functions</span></a>.
Adapters can ingest data from many different input sources, including Python
modules as in the <a class="reference external" href="https://github.com/HUBioDataLab/CROssBAR-BioCypher-Migration">CROssBAR
adapter</a> (which
uses the OmniPath backend software, PyPath, for downloading and caching data),
advanced file management formats such as Parquet as in the <a class="reference external" href="https://github.com/saezlab/OTAR-BioCypher">Open Targets
adapter</a>, or simple CSV files as in
the <a class="reference external" href="https://github.com/saezlab/DepMap-BioCypher">Dependency Map adapter</a>.</p>
<p>The recommended mode of access into BioCypher functionality is via the
<a class="reference internal" href="reference.html#biocypher._driver.Driver" title="biocypher._driver.Driver"><code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher._driver.Driver</span></code></a> class. It can be called either
starting in “offline mode” using <code class="docutils literal notranslate"><span class="pre">offline</span> <span class="pre">=</span> <span class="pre">True</span></code>, i.e., without
connection to a running Neo4j instance, or by providing authentication
details via arguments or configuration file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">biocypher</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">biocypher</span><span class="o">.</span><span class="n">Driver</span><span class="p">(</span>
  <span class="n">offline</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
  <span class="n">db_uri</span> <span class="o">=</span> <span class="s2">&quot;bolt://localhost:7687&quot;</span><span class="p">,</span>
  <span class="n">db_user</span> <span class="o">=</span> <span class="s2">&quot;neo4j&quot;</span><span class="p">,</span>
  <span class="n">db_passwd</span> <span class="o">=</span> <span class="s2">&quot;password&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use the APOC library for Neo4j, which is not included automatically, but
needs to be installed as a plugin to the DMBS. For more information, please
refer to the <a class="reference external" href="https://neo4j.com/labs/apoc/">APOC documentation</a>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>The settings for the BioCypher driver can also be specified in a configuration
file. For more details, please refer to the <a class="reference internal" href="installation.html#config"><span class="std std-ref">Setup instructions</span></a>.</p>
</div>
<p>The main function of the adapter is to pass data into BioCypher, usually
as some form of iterable (commonly a list or generator of items). As a
minimal example, we load a list of proteins with identifiers, trivial
names, and molecular masses from a (fictional) CSV:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># read into data frame</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;file.csv&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">proteins</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c1"># yield proteins from data frame</span>
<span class="k">def</span> <span class="nf">node_generator</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">proteins</span><span class="p">:</span>
    <span class="n">_id</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;uniprot_id&quot;</span><span class="p">]</span>
    <span class="n">_type</span> <span class="o">=</span> <span class="s2">&quot;protein&quot;</span>
    <span class="n">_props</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;trivial_name&quot;</span><span class="p">]</span>
      <span class="s2">&quot;mm&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;molecular_mass&quot;</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">yield</span> <span class="p">(</span><span class="n">_id</span><span class="p">,</span> <span class="n">_type</span><span class="p">,</span> <span class="n">_props</span><span class="p">)</span>

<span class="c1"># write biocypher nodes</span>
<span class="n">d</span><span class="o">.</span><span class="n">write_nodes</span><span class="p">(</span><span class="n">node_generator</span><span class="p">())</span>
</pre></div>
</div>
<p>For nodes, BioCypher expects a tuple containing three entries; the preferred
identifier of the node, the type of entity, and a dictionary containing all
other properties (can be empty). What BioCypher does with the received
information is determined largely by the schema configuration detailed below.</p>
<p>For advanced usage, the type of node or edge can be determined
programatically. Properties do not need to be explicitly called one by
one; they can be passed in as a complete dictionary of all entries and
filtered inside BioCypher by detailing the desired properties per node
type in the schema configuration file.</p>
</section>
<section id="the-schema-configuration-yaml-file">
<span id="qs-schema-config"></span><h2>The schema configuration YAML file<a class="headerlink" href="#the-schema-configuration-yaml-file" title="Permalink to this heading"></a></h2>
<p>The second important component of translation into a
BioCypher-compatible property graph is the specification of graph
constituents and their mode of representation in the graph. For
instance, we want to add a representation for proteins to the OmniPath
graph, and the proteins should be represented as nodes. To make this
known to the BioCypher module, we use the
<a class="reference external" href="https://github.com/saezlab/BioCypher/blob/main/biocypher/_config/schema_config.yaml">schema-config.yaml</a>,
which details <em>only</em> the immediate constituents of the desired graph.
Since the identifier systems in the Biolink schema are not comprehensive
and offer many alternatives, we currently use the CURIE prefixes
directly as given by <a class="reference external" href="https://bioregistry.io">Bioregistry</a>. For
instance, a protein could be represented, for instance, by a UniProt
identifier, the corresponding ENSEMBL identifier, or an HGNC gene
symbol. The CURIE prefix for “Uniprot Protein” is <code class="docutils literal notranslate"><span class="pre">uniprot</span></code>, so a
consistent protein schema definition would be:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">protein</span><span class="p">:</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">node</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">uniprot</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For BioCypher classes, similar to the internal representation in the Biolink
model, we use lower sentence-case notation, e.g., <code class="docutils literal notranslate"><span class="pre">protein</span></code> and <code class="docutils literal notranslate"><span class="pre">small</span> <span class="pre">molecule</span></code>. For file names and Neo4j labels, these are converted to PascalCase.</p>
</div>
<p>In the protein case, we are specifying its representation as a node,
that we wish to use the UniProt identifier as the main identifier for
proteins, and that proteins in the input coming from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> carry
the label <code class="docutils literal notranslate"><span class="pre">protein</span></code> (in lowercase). Should one wish to use ENSEMBL
notation instead of UniProt, the corresponding CURIE prefix, in this
case, <code class="docutils literal notranslate"><span class="pre">ensembl</span></code>, can be substituted.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">protein</span><span class="p">:</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">node</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ensembl</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
</pre></div>
</div>
<p>If there exists no identifier system that is suitable for coverage of
the data, the standard field <code class="docutils literal notranslate"><span class="pre">id</span></code> can be used; this will not result in
the creation of a named property that reflects the identifier of each
node. See below for an example. The <code class="docutils literal notranslate"><span class="pre">preferred_id</span></code> field can in this case also
be omitted entirely; this will lead to the same outcome (<code class="docutils literal notranslate"><span class="pre">id</span></code>).</p>
<p>The other slots of a graph constituent entry contain information
BioCypher needs to receive the input data correctly and construct the
graph accordingly. For “Named Thing” entities such as the protein, this
includes the mode of representation (YAML entry <code class="docutils literal notranslate"><span class="pre">represented_as</span></code>),
which can be <code class="docutils literal notranslate"><span class="pre">node</span></code> or <code class="docutils literal notranslate"><span class="pre">edge</span></code>. Proteins can only feasibly
represented as nodes, but for other entities, such as interactions or
aggregates, representation can be both as node or as edge. In Biolink,
these belong to the super-class
<a class="reference external" href="https://biolink.github.io/biolink-model/docs/associations.html">Associations</a>.
For associations, BioCypher additionally requires the specification of
the source and target of the association; for instance, a
post-translational interaction occurs between proteins, so the source
and target attribute in the <code class="docutils literal notranslate"><span class="pre">schema-config.yaml</span></code> will both be
<code class="docutils literal notranslate"><span class="pre">protein</span></code>.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">post translational interaction</span><span class="p">:</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">node</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">id</span>
<span class="w">  </span><span class="nt">source</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
<span class="w">  </span><span class="nt">target</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">post_translational</span>
</pre></div>
</div>
<p>For the post-translational interaction, which is an association, we are
specifying representation as a node (prompting BioCypher to create not
only the node but also two edges connecting to the proteins
participating in any particular post-translational interaction). In
other words, we are reifying the post-translational interaction in order
to have a node to which other nodes can be linked; for instance, we
might want to add a publication to a particular interaction to serve as
source of evidence, which is only possible for nodes in a property
graph, not for edges.</p>
<p>Since there are no systematic identifiers for post-translational
interactions, we concatenate the protein ids and relevant properties of
the interaction to a new unique id. We prevent creation of a specific
named property by specifying <code class="docutils literal notranslate"><span class="pre">id</span></code> as the identifier system in this case.
If a specific property name (in addition to the generic <code class="docutils literal notranslate"><span class="pre">id</span></code> field) is
desired, one can use any arbitrary string as a designation for this
identifier, which will then be a named property on the
<code class="docutils literal notranslate"><span class="pre">PostTranslationalInteraction</span></code> nodes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BioCypher accepts non-Biolink IDs since not all possible entries possess a
systematic identifier system, whereas the entity class (<code class="docutils literal notranslate"><span class="pre">protein</span></code>,
<code class="docutils literal notranslate"><span class="pre">post</span> <span class="pre">translational</span> <span class="pre">interaction</span></code>) has to be included in the Biolink schema and
spelled identically. For this reason, we <a class="reference internal" href="#qs-biolink"><span class="std std-ref">extend the Biolink schema</span></a>
in cases where there exists no entry for our entity of choice. Further, we are
specifying the source and target classes of our association (both <code class="docutils literal notranslate"><span class="pre">protein</span></code>),
the label we provide in the input from <code class="docutils literal notranslate"><span class="pre">PyPath</span></code> (<code class="docutils literal notranslate"><span class="pre">post_translational</span></code>).</p>
</div>
<p>If we wanted the interaction to be represented in the graph as an edge,
we would also need to supply an additional - arbitrary - property,
<code class="docutils literal notranslate"><span class="pre">label_as_edge</span></code>, which would be used as the relationship type; this
could for instance be <code class="docutils literal notranslate"><span class="pre">INTERACTS_POST_TRANSLATIONALLY</span></code>, following the
property graph database consensus that property graph edges are
represented in all upper case form and as verbs, to distinguish from
nodes that are represented in PascalCase and as nouns. This would modify
the above example to the following:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">post translational interaction</span><span class="p">:</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">edge</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">id</span>
<span class="w">  </span><span class="nt">source</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
<span class="w">  </span><span class="nt">target</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">protein</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">post_translational</span>
<span class="w">  </span><span class="nt">label_as_edge</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">INTERACTS_POST_TRANSLATIONALLY</span>
</pre></div>
</div>
</section>
<section id="the-biolink-model-extension">
<span id="qs-biolink"></span><h2>The Biolink model extension<a class="headerlink" href="#the-biolink-model-extension" title="Permalink to this heading"></a></h2>
<section id="soft-extensions">
<h3>Soft extensions<a class="headerlink" href="#soft-extensions" title="Permalink to this heading"></a></h3>
<p>In some cases that are not too complex, the Biolink model can be
extended using only implicit subclasses given in the BioCypher
schema_config.yaml file. Soft extensions can be achieved in two ways:</p>
<ul class="simple">
<li><p>via <a class="reference internal" href="#qs-implicit"><span class="std std-ref">implicit subclasses</span></a> of existing Biolink classes by supplying
multiple preferred ids and input labels in the <code class="docutils literal notranslate"><span class="pre">schema_config.yaml</span></code></p></li>
<li><p>via <a class="reference internal" href="#qs-explicit"><span class="std std-ref">explicit subclasses</span></a> of existing Biolink classes by supplying an
<code class="docutils literal notranslate"><span class="pre">is_a</span></code> parameter to any non-biolink class, referring to an existing
one</p></li>
</ul>
<section id="implicit-subclasses">
<span id="qs-implicit"></span><h4>Implicit subclasses<a class="headerlink" href="#implicit-subclasses" title="Permalink to this heading"></a></h4>
<p>For instance, Pathway annotations are supplied by multiple sources,
e.g., <a class="reference external" href="https://www.genome.jp/kegg/pathway.html">KEGG</a> and
<a class="reference external" href="https://reactome.org/">Reactome</a>, which do not allow direct mapping due
to their distinct make-up. In this case, we can use the
schema_config.yaml to implicitly extend the Biolink model by specifying
more than one preferred_id and label_in_input (in a paired manner):</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">pathway</span><span class="p">:</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">node</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">reactome</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">kegg</span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">reactome</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">kegg_pathway</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>This pattern will be parsed by BioCypher to yield two implicit children
of the Biolink entity “pathway” by prepending the preferred ID to the
label (<code class="docutils literal notranslate"><span class="pre">reactome.pathway</span></code> and <code class="docutils literal notranslate"><span class="pre">kegg.pathway</span></code>). The input labels again are
arbitrary and can be adjusted to fit the way these pathways are
represented in the raw data.</p>
<p>This will allow both datasets to be represented as pathways in the final
graph with granular access to each one and without information loss, but
will also enable aggregate query of all pathways by calling the parent
entity, <code class="docutils literal notranslate"><span class="pre">pathway</span></code>.</p>
</section>
<section id="explicit-subclasses">
<span id="qs-explicit"></span><h4>Explicit subclasses<a class="headerlink" href="#explicit-subclasses" title="Permalink to this heading"></a></h4>
<p>For example, adding the child <code class="docutils literal notranslate"><span class="pre">tissue</span></code> to the existing Biolink class
<code class="docutils literal notranslate"><span class="pre">gross</span> <span class="pre">anatomical</span> <span class="pre">structure</span></code> as a specification:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">tissue</span><span class="p">:</span>
<span class="w">  </span><span class="nt">is_a</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gross anatomical structure</span>
<span class="w">  </span><span class="nt">represented_as</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">node</span>
<span class="w">  </span><span class="nt">preferred_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">uberon</span>
<span class="w">  </span><span class="nt">label_in_input</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">tissue</span>
</pre></div>
</div>
<p>This will create a “faux” Biolink class at BioCypher runtime, extending
the hierarchical tree to include <code class="docutils literal notranslate"><span class="pre">tissue</span></code> as a
<code class="docutils literal notranslate"><span class="pre">gross</span> <span class="pre">anatomical</span> <span class="pre">structure</span></code>, preserving the entire inheritance of the
parent class. BioCypher can create arbitrarily long inheritance
structures by accepting lists as input to the <code class="docutils literal notranslate"><span class="pre">is_a</span></code> field, as long as
the final entry in the list is an existant Biolink entity. All entities
along the list will be established as virtual children of the Biolink
parent node. For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">mutation to tissue association</span><span class="p">:</span>
<span class="w">  </span><span class="nt">is_a</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span>
<span class="w">    </span><span class="nv">genotype to tissue association</span><span class="p p-Indicator">,</span>
<span class="w">    </span><span class="nv">entity to tissue association</span><span class="p p-Indicator">,</span>
<span class="w">    </span><span class="nv">association</span>
<span class="w">  </span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>Where only <code class="docutils literal notranslate"><span class="pre">association</span></code> is an existent class in the Biolink model.
Generally, it is preferable to add extensions to the Biolink model to
the original repository via a pull request to ensure compatibility with
other DBs. Creating a hard-wired extension as described in the next
section can be a first step towards a pull request to the Biolink repo.</p>
</section>
</section>
<section id="hard-wired-extensions">
<h3>Hard-wired extensions<a class="headerlink" href="#hard-wired-extensions" title="Permalink to this heading"></a></h3>
<p>The post-translational interaction that we would like to model in
OmniPath has no literal counterpart in the Biolink model, due to
Biolink’s design philosophy. The most granular level of interactions as
Biolink class is the
<a class="reference external" href="https://biolink.github.io/biolink-model/docs/PairwiseMolecularInteraction.html">PairwiseMolecularInteraction</a>;
all more granular relationships should be encoded in the properties of
the class, which has severe performance implications for property graph
representation, for instance in filtering for specific relationship
types. Briefly, it is the difference between being able to selectively
return only relationships of a certain class (eg, post-translational),
and having to return all relationships to filter for the ones possessing
the correct property in a second step.</p>
<p>Therefore, we extend the Biolink model in places where it is necessary
for the BioCypher translation and integration to work. The extended
model is the central Biolink YAML file with additions following the same
<a class="reference external" href="https://linkml.io">LinkML</a> syntax as is used in the original model.
Depending on the extent of the modification, not only new classes are
introduced, but also new mixin categories (eg, “microRNA or siRNA” to
account for different types of small noncoding RNA). We provide <a class="reference external" href="https://github.com/saezlab/BioCypher/blob/main/biocypher/_config/biocypher-biolink-model.yaml">our
extended version of the Biolink
model</a>
with the BioCypher repository.</p>
<p>Changes or additions desired by the user can be introduced locally in this file
without having to modify remote contents. Users also have the option to create
their own modified version of the Biolink YAML file under a different file name
and specify that path in the <code class="docutils literal notranslate"><span class="pre">user_schema_config_path</span></code> argument of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">biocypher.Driver</span></code> class, which handles all communication between
BioCypher and Biolink.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial.html" class="btn btn-neutral float-right" title="BioCypher Tutorial - Basics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2023, BioCypher developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>